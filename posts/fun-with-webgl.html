<link href="../assets/css/bootstrap.min.css" rel="stylesheet">
<link href="../assets/css/philippmatthes.css" rel="stylesheet">
<link href="../assets/css/spinner.css" rel="stylesheet">

<body style="width: 100%; height: 100%" class="bg-black">
<div class="lds-ring"><div></div><div></div><div></div><div></div></div>
<div id="error" style="display: none;">
    Your browser does not support <strong>WEBGL_draw_buffers</strong>.<br><br>
    This demo will not work.
</div>
</body>

<script src="../assets/js/jquery-3.3.1.min.js"></script>
<script src="../assets/js/bootstrap.min.js"></script>

<script src="../assets/js/fun-with-colors.js"></script>
<script src="../assets/js/three.min.js"></script>
<script src="../assets/js/OrbitControls.js"></script>


<script id="gbuffer-vert" type="x-shader/x-vertex">
    #extension GL_EXT_draw_buffers : require

    uniform mat4 projectionMatrix;
    uniform mat4 modelViewMatrix;
    uniform mat3 normalMatrix;
    uniform vec3 cameraPosition;

    uniform float zFar;
    uniform float zNear;

    attribute vec4 position;
    attribute vec3 normal;
    attribute vec2 uv;

    varying vec3 vNormal;
    varying vec3 vDepth;

    vec3 calculateSmoothNormals() {
        vec4 mvPosition = modelViewMatrix * position;
        vec3 transformedNormal = normalMatrix * normal;
        return normalize(transformedNormal);
    }

    vec3 calculateNormalizedDepth() {
        float distanceToCamera = length(cameraPosition.xyz - position.xyz);
        float normalizedDepth = (distanceToCamera) / (zNear + zFar);
        return vec3(normalizedDepth);
    }

    void main() {
        vNormal = calculateSmoothNormals();
        vDepth = calculateNormalizedDepth();
        gl_Position = projectionMatrix * modelViewMatrix * position;
    }

</script>
<script id="gbuffer-frag" type="x-shader/x-fragment">
    #extension GL_EXT_draw_buffers : require
    precision mediump float;

    varying vec3 vNormal;
    varying vec3 vDepth;

    void main() {
        gl_FragData[0] = vec4(vDepth, 0.0);
        gl_FragData[1] = vec4(vNormal, 0.0);
    }

</script>

<script id="render-vert" type="x-shader/x-vertex">
    uniform mat4 projectionMatrix;
    uniform mat4 viewMatrix;
    uniform mat4 modelViewMatrix;
    uniform vec3 cameraPosition;

    attribute vec2 uv;
    attribute vec4 position;

    varying vec2 vUv;
    varying vec3 vIncident;
    varying mat4 mViewProjectionMatrix;

    void main() {
        vUv = uv;
        vIncident = normalize(position.xyz - cameraPosition.xyz);
        mViewProjectionMatrix = viewMatrix * projectionMatrix;
        gl_Position = projectionMatrix * modelViewMatrix * position;
    }
</script>

<script id="render-frag" type="x-shader/x-fragment">
    precision mediump float;

    uniform sampler2D tFrontFaceDepth;
    uniform sampler2D tFrontFaceNormal;
    uniform sampler2D tBackFaceDepth;
    uniform sampler2D tBackFaceNormal;
    uniform samplerCube tCube;
    uniform float zFar;
    uniform float zNear;

    varying vec2 vUv;
    varying vec3 vIncident;
    varying mat4 mViewProjectionMatrix;

    const float refractionIndex = 1.1;

    void main() {
        float frontFaceDepth = texture2D(tFrontFaceDepth, vUv).r;
        float backFaceDepth = texture2D(tBackFaceDepth, vUv).r;
        vec3 frontFaceNormal = texture2D(tFrontFaceNormal, vUv).rgb;

        // Calculate refraction
        vec3 frontFaceRefraction = refract(normalize(vIncident), normalize(frontFaceNormal), refractionIndex);
        float depthDiff = (backFaceDepth - frontFaceDepth) * (zFar + zNear);
        vec3 backFaceIntersection = normalize(frontFaceRefraction) * depthDiff;
        vec2 projectedIntersection = (mViewProjectionMatrix * vec4(backFaceIntersection, 1.0)).xy;
        vec2 uvProjectedIntersection = (projectedIntersection + 1.0) / 2.0;
        vec3 backFaceNormals = texture2D(tBackFaceNormal, uvProjectedIntersection).rgb;
        vec3 backFaceRefraction = refract(normalize(frontFaceRefraction), normalize(backFaceNormals), refractionIndex);
        vec4 colorFrontFaceRefraction = textureCube(tCube, frontFaceRefraction);
        vec4 colorBackFaceRefraction = textureCube(tCube, backFaceRefraction);
        vec4 colorRefraction = mix(colorFrontFaceRefraction, colorBackFaceRefraction, 0.5);

        // Calculate reflection
        vec3 reflection = reflect(vIncident, frontFaceNormal);
        vec4 colorReflection = textureCube(tCube, reflection);

        gl_FragColor = mix(colorReflection, colorRefraction, 0.8);
    }

</script>

<script>
var renderer;
var controls;
var camera;
var backFaceScene, frontFaceScene;
var backFaceTarget, frontFaceTarget;
var postScene, postCamera;
var supportsMRT = true;

$(document).ready(function() {
    init();
    animate();
});

function init() {

    var cubeLoader = new THREE.CubeTextureLoader()
    .setPath('https://philippmatthes.github.io/assets/img/skybox/')
    .load([
        "posx.jpg",
        "negx.jpg",
        "posy.jpg",
        "negy.jpg",
        "posz.jpg",
        "negz.jpg"]
    );

    const zNear = 1.0;
    const zFar = 40.0;

    renderer = new THREE.WebGLRenderer({alpha: true});

    if ( !renderer.extensions.get('WEBGL_draw_buffers') ) {
        supportsMRT = false;
        document.querySelector('#error').style.display = 'block';
        return;
    }

    renderer.setPixelRatio( window.devicePixelRatio );
    renderer.setSize( window.innerWidth, window.innerHeight );
    document.body.appendChild(renderer.domElement);

    camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, zNear, zFar );
    camera.position.z = -15;

    controls = new THREE.OrbitControls( camera, renderer.domElement );
    controls.enableDamping = true;
    controls.dampingFactor = 0.25;
    controls.rotateSpeed = 0.35;

    // Create a multi render target with Float buffers
    backFaceTarget = createTarget();
    frontFaceTarget = createTarget();

    backFaceScene = new THREE.Scene();
    frontFaceScene = new THREE.Scene();

    const radius = 3.5;
    const tube = 1.5;
    const radialSegments = 16;
    const tubularSegments = 64;
    const p = 2;
    const q = 3;
    var geometry = new THREE.TorusKnotBufferGeometry(radius, tube, tubularSegments, radialSegments, p, q);

    var frontFaceMaterial = new THREE.RawShaderMaterial({
        side: THREE.FrontSide,
        uniforms: {
            zNear: { value: zNear },
            zFar: { value: zFar }
        },
        vertexShader: document.querySelector('#gbuffer-vert').textContent.trim(),
        fragmentShader: document.querySelector('#gbuffer-frag').textContent.trim()
    });
    var backFaceMaterial = new THREE.RawShaderMaterial({
        side: THREE.BackSide,
        uniforms: {
            zNear: { value: zNear },
            zFar: { value: zFar }
        },
        vertexShader: document.querySelector('#gbuffer-vert').textContent.trim(),
        fragmentShader: document.querySelector('#gbuffer-frag').textContent.trim()
    });

    var frontFaceTorus = new THREE.Mesh(geometry, frontFaceMaterial);
    var backFaceTorus = new THREE.Mesh(geometry, backFaceMaterial);

    frontFaceScene.add(frontFaceTorus);
    backFaceScene.add(backFaceTorus);

    // Setup post processing stage
    postCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
    var postMaterial = new THREE.RawShaderMaterial({
        vertexShader: document.querySelector('#render-vert').textContent.trim(),
        fragmentShader: document.querySelector('#render-frag').textContent.trim(),
        uniforms: {
            zNear: { value: zNear },
            zFar: { value: zFar },
            tFrontFaceDepth: { type: 't', value: frontFaceTarget.attachments[0] },
            tFrontFaceNormal: { type: 't', value: frontFaceTarget.attachments[1] },
            tBackFaceDepth: { type: 't', value: backFaceTarget.attachments[0] },
            tBackFaceNormal: { type: 't', value: backFaceTarget.attachments[1] },
            tCube: { value: cubeLoader }
        }
    });
    var postPlane = new THREE.PlaneGeometry(2, 2);
    var postQuad = new THREE.Mesh(postPlane, postMaterial);
    postScene = new THREE.Scene();
    postScene.add(postQuad);
    postScene.background = cubeLoader;

    onWindowResize();
    window.addEventListener( 'resize', onWindowResize, false );
    document.addEventListener( 'mousedown', onMouseDown, false );
}

function createTarget() {
    var t = new THREE.WebGLMultiRenderTarget( window.innerWidth, window.innerHeight );
    t.texture.format = THREE.RGBFormat;
    t.texture.minFilter = THREE.NearestFilter;
    t.texture.magFilter = THREE.NearestFilter;
    t.texture.type = THREE.FloatType;
    t.texture.generateMipmaps = false;
    t.stencilBuffer = false;
    t.depthBuffer = true;
    t.attachments.push( t.texture.clone() );
    return t;
}

function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();

    var dpr = renderer.getPixelRatio();
    frontFaceTarget.setSize( window.innerWidth * dpr, window.innerHeight * dpr );
    backFaceTarget.setSize( window.innerWidth * dpr, window.innerHeight * dpr );
    renderer.setSize( window.innerWidth, window.innerHeight );
}

function onMouseDown() {
    console.log("Clickedy click");
}

function animate() {

    if ( !supportsMRT ) return;
    controls.update();

    renderer.render( frontFaceScene, camera, frontFaceTarget );
    renderer.render( backFaceScene, camera, backFaceTarget );
    renderer.render( postScene, postCamera );

    requestAnimationFrame( animate );

}

</script>