<link href="../assets/css/bootstrap.min.css" rel="stylesheet">
<link href="../assets/css/philippmatthes.css" rel="stylesheet">
<link href="../assets/css/spinner.css" rel="stylesheet">
<link href="../assets/css/roboto.css" rel="stylesheet">

<body style="width: 100%; height: 100%" class="bg-black">
<div class="lds-ring"><div></div><div></div><div></div><div></div></div>
<button id="pass-button" onclick="showNextPass()" style="position: absolute; bottom: 1rem; left: 50%; transform: translate(-50%, 0);"
        class="btn btn-dark btn-xl rounded-pill mt-5 bg-black border-animation"></button>
</body>

<script src="../assets/js/jquery-3.3.1.min.js"></script>
<script src="../assets/js/bootstrap.min.js"></script>

<script src="../assets/js/fun-with-colors.js"></script>
<script src="../assets/js/three.min.js"></script>
<script src="../assets/js/OrbitControls.js"></script>

<script id="depth-vert" type="x-shader/x-vertex">
    uniform mat4 projectionMatrix;
    uniform mat4 modelViewMatrix;
    uniform vec3 cameraPosition;

    uniform float zFar;
    uniform float zNear;

    attribute vec4 position;

    varying vec3 vDepth;

    vec3 calculateNormalizedDepth() {
        float distanceToCamera = length(cameraPosition.xyz - position.xyz);
        float normalizedDepth = (distanceToCamera) / (zNear + zFar);
        return vec3(normalizedDepth);
    }

    void main() {
        vDepth = calculateNormalizedDepth();
        gl_Position = projectionMatrix * modelViewMatrix * position;
    }

</script>
<script id="depth-frag" type="x-shader/x-fragment">
    precision mediump float;

    varying vec3 vDepth;

    void main() {
        gl_FragColor = vec4(vDepth, 1.0);
    }

</script>

<script id="normals-vert" type="x-shader/x-vertex">
    uniform mat4 projectionMatrix;
    uniform mat4 modelViewMatrix;
    uniform mat3 normalMatrix;

    attribute vec4 position;
    attribute vec3 normal;

    varying vec3 vNormal;

    vec3 calculateSmoothNormals() {
        vec4 mvPosition = modelViewMatrix * position;
        vec3 transformedNormal = normalMatrix * normal;
        return normalize(transformedNormal);
    }

    void main() {
        vNormal = calculateSmoothNormals();
        gl_Position = projectionMatrix * modelViewMatrix * position;
    }

</script>
<script id="normals-frag" type="x-shader/x-fragment">
    precision mediump float;

    varying vec3 vNormal;

    void main() {
        gl_FragColor = vec4(vNormal, 1.0);
    }

</script>

<script id="render-vert" type="x-shader/x-vertex">
    uniform mat4 projectionMatrix;
    uniform mat4 viewMatrix;
    uniform mat4 modelViewMatrix;
    uniform vec3 cameraPosition;

    attribute vec4 position;

    varying vec3 vIncident;

    void main() {
        vIncident = normalize(position.xyz - cameraPosition.xyz);
        gl_Position = projectionMatrix * modelViewMatrix * position;
    }
</script>

<script id="render-frag" type="x-shader/x-fragment">
    precision mediump float;

    uniform sampler2D tFrontFaceDepth;
    uniform sampler2D tFrontFaceNormal;
    uniform sampler2D tBackFaceDepth;
    uniform sampler2D tBackFaceNormal;
    uniform samplerCube tCube;
    uniform float zFar;
    uniform float zNear;
    uniform float width;
    uniform float height;
    uniform float windowDeviceRatio;
    uniform int renderFeature;

    varying vec3 vIncident;

    const float refractionIndex = 1.3;
    const float refractionDelta = 0.02;

    void main() {
        vec2 textureCoordinates = vec2(gl_FragCoord.x / (width), gl_FragCoord.y / (height));

        float frontFaceDepth = texture2D(tFrontFaceDepth, textureCoordinates).r;
        float backFaceDepth = texture2D(tBackFaceDepth, textureCoordinates).r;
        vec3 frontFaceNormal = texture2D(tFrontFaceNormal, textureCoordinates).rgb;
        vec3 backFaceNormal = texture2D(tBackFaceNormal, textureCoordinates).rgb;

        vec3 frontFaceRefractionR = refract(vIncident, frontFaceNormal, (1.0 / refractionIndex) + refractionDelta);
        vec3 frontFaceRefractionG = refract(vIncident, frontFaceNormal, 1.0 / refractionIndex);
        vec3 frontFaceRefractionB = refract(vIncident, frontFaceNormal, (1.0 / refractionIndex) - refractionDelta);

        vec3 backFaceRefractionR = refract(vIncident, backFaceNormal, (1.0 / refractionIndex) + refractionDelta);
        vec3 backFaceRefractionG = refract(vIncident, backFaceNormal, 1.0 / refractionIndex);
        vec3 backFaceRefractionB = refract(vIncident, backFaceNormal, (1.0 / refractionIndex) - refractionDelta);

        float colorFrontFaceRefractionR = textureCube(tCube, frontFaceRefractionR).r;
        float colorFrontFaceRefractionG = textureCube(tCube, frontFaceRefractionG).g;
        float colorFrontFaceRefractionB = textureCube(tCube, frontFaceRefractionB).b;

        float colorBackFaceRefractionR = textureCube(tCube, backFaceRefractionR).r;
        float colorBackFaceRefractionG = textureCube(tCube, backFaceRefractionG).g;
        float colorBackFaceRefractionB = textureCube(tCube, backFaceRefractionB).b;

        vec4 colorFrontFaceRefraction = vec4(colorFrontFaceRefractionR, colorFrontFaceRefractionG, colorFrontFaceRefractionB, 1.0);
        vec4 colorBackFaceRefraction = vec4(colorBackFaceRefractionR, colorBackFaceRefractionG, colorBackFaceRefractionB, 1.0);
        vec4 colorRefraction = mix(colorFrontFaceRefraction, colorBackFaceRefraction, 0.5);

        // Calculate reflection
        vec3 reflection = reflect(vIncident, frontFaceNormal);
        vec3 backFaceReflection = reflect(vIncident, backFaceNormal);
        vec4 colorReflection = textureCube(tCube, reflection);
        vec4 colorBackFaceReflection = textureCube(tCube, backFaceReflection);

        // Calculate depth effect
        float colorDepth = (backFaceDepth - frontFaceDepth);

        if (renderFeature == 0) {
            gl_FragColor = mix(mix(colorReflection, colorRefraction, 0.6), vec4(vec3(0.0), 1.0), colorDepth);
        } else if (renderFeature == 1) {
            gl_FragColor = vec4(backFaceNormal, 1.0);
        } else if (renderFeature == 2) {
            gl_FragColor = vec4(vec3(backFaceDepth), 1.0);
        } else if (renderFeature == 3) {
            gl_FragColor = vec4(frontFaceNormal, 1.0);
        } else if (renderFeature == 4) {
            gl_FragColor = vec4(vec3(frontFaceDepth), 1.0);
        } else if (renderFeature == 5) {
            gl_FragColor = vec4(vec3(backFaceDepth - frontFaceDepth), 1.0);
        } else if (renderFeature == 6) {
            gl_FragColor = colorBackFaceRefraction;
        } else if (renderFeature == 7) {
            gl_FragColor = colorFrontFaceRefraction;
        } else if (renderFeature == 8) {
            gl_FragColor = colorBackFaceReflection;
        } else if (renderFeature == 9) {
            gl_FragColor = colorReflection;
        }
    }

</script>

<script>
var renderer;
var controls;
var camera;
var backFaceNormalsScene, frontFaceNormalsScene, backFaceDepthScene, frontFaceDepthScene;
var backFaceNormalsTarget, frontFaceNormalsTarget, backFaceDepthTarget, frontFaceDepthTarget;
var postScene;
var postMaterial;
var geometry;
var renderFeatures = {
    0: "Back-/Frontface Refraction, Reflection and Depth",
    1: "Backface Normals",
    2: "Backface Depth",
    3: "Frontface Normals",
    4: "Frontface Depth",
    5: "Depth Difference",
    6: "Backface Refraction",
    7: "Frontface Refraction",
    8: "Backface Reflection",
    9: "Frontface Reflection"
};
const maxRenderFeatures = 10;
$("#pass-button").text(renderFeatures[0]);

$(document).ready(function() {
    init();
    animate();
});

function init() {
    var width = window.innerWidth;
    var height = window.innerHeight;

    var cubeLoader = new THREE.CubeTextureLoader()
        .setPath('../assets/img/skybox/')
        .load([
            "posx.jpg",
            "negx.jpg",
            "posy.jpg",
            "negy.jpg",
            "posz.jpg",
            "negz.jpg"]
        );

    const zNear = 1.0;
    const zFar = 40.0;

    renderer = new THREE.WebGLRenderer({alpha: true});

    // renderer.setPixelRatio( window.deviceRatio );
    renderer.setSize( width, height );
    document.body.appendChild(renderer.domElement);

    camera = new THREE.PerspectiveCamera( 70, width / height, zNear, zFar );
    camera.position.z = -15;

    controls = new THREE.OrbitControls( camera, renderer.domElement );
    controls.enableDamping = true;
    controls.dampingFactor = 0.25;
    controls.autoRotate = true;
    controls.autoRotateSpeed = 0.4;
    controls.rotateSpeed = 0.35;

    backFaceNormalsTarget = new THREE.WebGLRenderTarget(width, height);
    frontFaceNormalsTarget = new THREE.WebGLRenderTarget(width, height);
    backFaceDepthTarget = new THREE.WebGLRenderTarget(width, height);
    frontFaceDepthTarget = new THREE.WebGLRenderTarget(width, height);

    backFaceNormalsScene = new THREE.Scene();
    frontFaceNormalsScene = new THREE.Scene();
    backFaceDepthScene = new THREE.Scene();
    frontFaceDepthScene = new THREE.Scene();
    postScene = new THREE.Scene();

    const radius = 3.5;
    const tube = 1.5;
    const radialSegments = 16;
    const tubularSegments = 64;
    const p = 2;
    const q = 3;
    geometry = new THREE.TorusKnotBufferGeometry(radius, tube, tubularSegments, radialSegments, p, q);

    // geometry = new THREE.BoxGeometry(10, 10, 10);
    //geometry = new THREE.SphereGeometry(10, 10, 10);

    var frontFaceDepthMaterial = new THREE.RawShaderMaterial({
        side: THREE.FrontSide,
        uniforms: {
            zNear: { value: zNear },
            zFar: { value: zFar }
        },
        vertexShader: document.querySelector('#depth-vert').textContent.trim(),
        fragmentShader: document.querySelector('#depth-frag').textContent.trim()
    });
    var backFaceDepthMaterial = new THREE.RawShaderMaterial({
        side: THREE.BackSide,
        uniforms: {
            zNear: { value: zNear },
            zFar: { value: zFar }
        },
        vertexShader: document.querySelector('#depth-vert').textContent.trim(),
        fragmentShader: document.querySelector('#depth-frag').textContent.trim()
    });
    var frontFaceNormalsMaterial = new THREE.RawShaderMaterial({
        side: THREE.FrontSide,
        uniforms: {},
        vertexShader: document.querySelector('#normals-vert').textContent.trim(),
        fragmentShader: document.querySelector('#normals-frag').textContent.trim()
    });
    var backFaceNormalsMaterial = new THREE.RawShaderMaterial({
        side: THREE.BackSide,
        uniforms: {},
        vertexShader: document.querySelector('#normals-vert').textContent.trim(),
        fragmentShader: document.querySelector('#normals-frag').textContent.trim()
    });
    postMaterial = new THREE.RawShaderMaterial({
        vertexShader: document.querySelector('#render-vert').textContent.trim(),
        fragmentShader: document.querySelector('#render-frag').textContent.trim(),
        uniforms: {
            zNear: { value: zNear },
            zFar: { value: zFar },
            width: { value: window.innerWidth },
            height: { value: window.innerHeight },
            tFrontFaceDepth: { value: frontFaceDepthTarget.texture },
            tFrontFaceNormal: { value: frontFaceNormalsTarget.texture },
            tBackFaceDepth: { value: backFaceDepthTarget.texture },
            tBackFaceNormal: { value: backFaceNormalsTarget.texture },
            tCube: { value: cubeLoader },
            renderFeature: {value: 0}
        }
    });

    var frontFaceNormalTorus = new THREE.Mesh(geometry, frontFaceNormalsMaterial);
    var backFaceNormalTorus = new THREE.Mesh(geometry, backFaceNormalsMaterial);
    var frontFaceDepthTorus = new THREE.Mesh(geometry, frontFaceDepthMaterial);
    var backFaceDepthTorus = new THREE.Mesh(geometry, backFaceDepthMaterial);
    var postSceneTorus = new THREE.Mesh(geometry, postMaterial);

    frontFaceNormalsScene.add(frontFaceNormalTorus);
    backFaceNormalsScene.add(backFaceNormalTorus);
    frontFaceDepthScene.add(frontFaceDepthTorus);
    backFaceDepthScene.add(backFaceDepthTorus);
    postScene.add(postSceneTorus);

    postScene.background = cubeLoader;

    onWindowResize();
    window.addEventListener( 'resize', onWindowResize, false );
}

function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();

    var dpr = renderer.getPixelRatio();
    frontFaceNormalsTarget.setSize( window.innerWidth * dpr, window.innerHeight * dpr );
    frontFaceDepthTarget.setSize( window.innerWidth * dpr, window.innerHeight * dpr );
    backFaceNormalsTarget.setSize( window.innerWidth * dpr, window.innerHeight * dpr );
    backFaceDepthTarget.setSize( window.innerWidth * dpr, window.innerHeight * dpr );
    renderer.setSize( window.innerWidth, window.innerHeight );
}

function showNextPass() {
    const nextFeature = (postMaterial.uniforms.renderFeature.value + 1) % maxRenderFeatures;
    postMaterial.uniforms.renderFeature.value = nextFeature;
    $("#pass-button").text(renderFeatures[nextFeature]);
}

function animate() {

    controls.update();

    renderer.render( frontFaceDepthScene, camera, frontFaceDepthTarget, true);
    renderer.render( frontFaceNormalsScene, camera, frontFaceNormalsTarget, true);
    renderer.render( backFaceDepthScene, camera, backFaceDepthTarget, true);
    renderer.render( backFaceNormalsScene, camera, backFaceNormalsTarget, true);
    renderer.render( postScene, camera );

    requestAnimationFrame( animate );

}

</script>
