<link href="../assets/css/bootstrap.min.css" rel="stylesheet">
<link href="../assets/css/philippmatthes.css" rel="stylesheet">
<link href="../assets/css/spinner.css" rel="stylesheet">

<body style="width: 100%; height: 100%" class="bg-black">
<div class="lds-ring"><div></div><div></div><div></div><div></div></div>
</body>

<script src="../assets/js/jquery-3.3.1.min.js"></script>
<script src="../assets/js/bootstrap.min.js"></script>

<script src="../assets/js/fun-with-colors.js"></script>
<script src="../assets/js/three.min.js"></script>
<script src="../assets/js/OrbitControls.js"></script>
<script src="../assets/js/EffectComposer.js"></script>
<script src="../assets/js/CopyShader.js"></script>
<script src="../assets/js/ShaderPass.js"></script>
<script src="../assets/js/RenderPass.js"></script>


<script id="vs-depth" type="webgl">
    vec4 calculatePosition() {
        return projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }

    void main() {
        gl_Position = calculatePosition();
    }
</script>
<script id="fs-depth" type="webgl">
    float calculateDepth() {
        return gl_FragCoord.z;
    }

    void main() {
        gl_FragColor = vec4(vec3(calculateDepth()), 1.0);
    }
</script>


<script id="vs" type="webgl">
    /*
     * Predefined inputs
     *
     * uniform mat4 modelMatrix;
     * uniform mat4 modelViewMatrix;
     * uniform mat4 projectionMatrix;
     * uniform mat4 viewMatrix;
     * uniform mat3 normalMatrix;
     * uniform vec3 cameraPosition;
     * attribute vec3 position;
     * attribute vec3 normal;
     * attribute vec2 uv;
     */

    varying vec3 vReflection;
    varying vec3 vRefraction;

    vec3 calculateNormalizedIncidentVector() {
        return normalize(position.xyz - cameraPosition.xyz);
    }

    vec3 calculateReflectionVector(vec3 normalizedIncidentVector, vec3 normalizedNormal) {
        return reflect(normalizedIncidentVector, normalizedNormal);
    }

    vec3 calculateRefractionVector(vec3 normalizedIncidentVector, vec3 normalizedNormal) {
        return refract(normalizedIncidentVector, normalizedNormal, 1.0 / 1.1);
    }

    vec4 calculatePosition() {
        return projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }

	void main() {
	    vec3 normalizedIncidentVector = calculateNormalizedIncidentVector();
	    vec3 normalizedNormal = normalize(normal);
	    vReflection = calculateReflectionVector(normalizedIncidentVector, normalizedNormal);
        vRefraction = calculateRefractionVector(normalizedIncidentVector, normalizedNormal);
        gl_Position = calculatePosition();
    }
</script>
<script id="fs" type="webgl">
    uniform samplerCube tCube;
    uniform sampler2D tDepthFront;
    uniform sampler2D tDepthBack;
    uniform sampler2D tNormalsBack;
    uniform float width;
    uniform float height;

    varying vec3 vReflection;
    varying vec3 vRefraction;

	void main() {
	    vec2 texturePosition = vec2(gl_FragCoord.x / width, gl_FragCoord.y / height);
	    vec4 reflection = textureCube(tCube, vReflection);
	    vec4 refraction = textureCube(tCube, vRefraction);
	    float depthFront = texture2D(tDepthFront, texturePosition).x;
	    float depthBack = texture2D(tDepthBack, texturePosition).x;
	    vec4 normalsBack = texture2D(tNormalsBack, texturePosition);
	    float depthDiff = clamp(1.0 - (depthFront - depthBack) * 5.0, 0.0, 1.0);
        gl_FragColor = mix(vec4(0.0), normalsBack, depthDiff);
    }
</script>

<script>

var scene, bufferSceneDepthFront, bufferSceneDepthBack, bufferSceneNormalsBack;
var renderer;
var camera;
var mesh, meshBack, meshFront, meshNormals;
var controls;
var renderTargetDepthFront, renderTargetDepthBack, renderTargetNormalsBack;

$(document).ready(function() {
    init();
    animate();
});

function init() {
    var width = window.innerWidth;
    var height = window.innerHeight;

    renderer = new THREE.WebGLRenderer({
        antialias: true,
        alpha: false
    });
    renderer.setClearColor( 0xffffff, 0 );
    renderer.setSize (width, height);
    document.body.appendChild (renderer.domElement);

    renderTargetDepthBack = new THREE.WebGLRenderTarget(width, height);
    renderTargetDepthFront = new THREE.WebGLRenderTarget(width, height);
    renderTargetNormalsBack = new THREE.WebGLRenderTarget(width, height);

    scene = new THREE.Scene();
    bufferSceneDepthFront = new THREE.Scene();
    bufferSceneDepthBack = new THREE.Scene();
    bufferSceneNormalsBack = new THREE.Scene();

    var cubeLoader = new THREE.CubeTextureLoader()
        .setPath( 'https://philippmatthes.github.io/assets/img/skybox/' )
        .load([
            "posx.jpg",
            "negx.jpg",
            "posy.jpg",
            "negy.jpg",
            "posz.jpg",
            "negz.jpg"]
        );

    scene.background = cubeLoader;

    var material = new THREE.ShaderMaterial({
        uniforms: {
            "tCube": cubeLoader,
            "tDepthFront": { value: renderTargetDepthFront.texture },
            "tDepthBack": { value: renderTargetDepthBack.texture },
            "tNormalsBack": { value: renderTargetNormalsBack.texture },
            "width": { value: width },
            "height": { value: height }
        },
        vertexShader:   $("#vs").text(),
        fragmentShader: $("#fs").text()
    });

    var backDepthMaterial = new THREE.MeshDepthMaterial({side: THREE.BackSide});
    var backNormalsMaterial = new THREE.MeshNormalMaterial({side: THREE.BackSide});
    var frontDepthMaterial = new THREE.MeshDepthMaterial({side: THREE.FrontSide});

    const radius = 3.5;
    const tube = 1.5;
    const radialSegments = 8;
    const tubularSegments = 64;
    const p = 2;
    const q = 3;
    var geometry = new THREE.TorusKnotBufferGeometry(radius, tube, tubularSegments, radialSegments, p, q);

    // geometry = new THREE.CubeGeometry(10, 10, 10);

    mesh = new THREE.Mesh(geometry, material);
    meshNormals = new THREE.Mesh(geometry, backNormalsMaterial);
    meshBack = new THREE.Mesh(geometry, backDepthMaterial);
    meshFront = new THREE.Mesh(geometry, frontDepthMaterial);

    scene.add(mesh);
    bufferSceneDepthBack.add(meshBack);
    bufferSceneDepthFront.add(meshFront);
    bufferSceneNormalsBack.add(meshNormals);

    camera = new THREE.PerspectiveCamera (45, width/height, 10, 50);
    camera.position.z = -25;
    camera.lookAt (new THREE.Vector3(0,0,0));

    controls = new THREE.OrbitControls( camera, renderer.domElement );
    controls.enableDamping = true;
    controls.dampingFactor = 0.25;
    controls.enableZoom = true;
    controls.autoRotate = true;
    controls.autoRotateSpeed = 0.3;
}


function animate() {
    controls.update();
    renderer.render(bufferSceneDepthBack, camera, renderTargetDepthBack, true);
    renderer.render(bufferSceneDepthFront, camera, renderTargetDepthFront, true);
    renderer.render(bufferSceneNormalsBack, camera, renderTargetNormalsBack, true);
    renderer.render(scene, camera);
    requestAnimationFrame(animate);
}


/*
window.addEventListener("resize", function() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}, false);
*/




</script>