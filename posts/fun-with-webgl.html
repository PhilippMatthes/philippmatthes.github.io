<link href="../assets/css/bootstrap.min.css" rel="stylesheet">
<link href="../assets/css/philippmatthes.css" rel="stylesheet">
<link href="../assets/css/spinner.css" rel="stylesheet">
<link href="../assets/css/roboto.css" rel="stylesheet">

<body style="width: 100%; height: 100%" class="bg-black">
<div class="lds-ring"><div></div><div></div><div></div><div></div></div>
<button id="pass-button" onclick="showNextPass()" style="position: absolute; bottom: 1rem; left: 50%; transform: translate(-50%, 0);"
        class="btn btn-dark btn-xl rounded-pill mt-5 bg-black border-animation"></button>
</body>

<script src="../assets/js/jquery-3.3.1.min.js"></script>
<script src="../assets/js/bootstrap.min.js"></script>

<script src="../assets/js/fun-with-colors.js"></script>
<script src="../assets/js/three.min.js"></script>
<script src="../assets/js/OrbitControls.js"></script>


<script id="gbuffer-vert" type="x-shader/x-vertex">
    #extension GL_EXT_draw_buffers : require

    uniform mat4 projectionMatrix;
    uniform mat4 modelViewMatrix;
    uniform mat3 normalMatrix;
    uniform vec3 cameraPosition;

    uniform float zFar;
    uniform float zNear;

    attribute vec4 position;
    attribute vec3 normal;
    attribute vec2 uv;

    varying vec3 vNormal;
    varying vec3 vDepth;

    vec3 calculateSmoothNormals() {
        vec4 mvPosition = modelViewMatrix * position;
        vec3 transformedNormal = normalMatrix * normal;
        return normalize(transformedNormal);
    }

    vec3 calculateNormalizedDepth() {
        float distanceToCamera = length(cameraPosition.xyz - position.xyz);
        float normalizedDepth = (distanceToCamera) / (zNear + zFar);
        return vec3(normalizedDepth);
    }

    void main() {
        vNormal = calculateSmoothNormals();
        vDepth = calculateNormalizedDepth();
        gl_Position = projectionMatrix * modelViewMatrix * position;
    }

</script>
<script id="gbuffer-frag" type="x-shader/x-fragment">
    #extension GL_EXT_draw_buffers : require
    precision mediump float;

    varying vec3 vNormal;
    varying vec3 vDepth;

    void main() {
        gl_FragData[0] = vec4(vDepth, 0.0);
        gl_FragData[1] = vec4(vNormal, 0.0);
    }

</script>

<script id="render-vert" type="x-shader/x-vertex">
    uniform mat4 projectionMatrix;
    uniform mat4 viewMatrix;
    uniform mat4 modelViewMatrix;
    uniform vec3 cameraPosition;

    attribute vec4 position;

    varying vec3 vIncident;

    void main() {
        vIncident = normalize(position.xyz - cameraPosition.xyz);
        gl_Position = projectionMatrix * modelViewMatrix * position;
    }
</script>

<script id="render-frag" type="x-shader/x-fragment">
    precision mediump float;

    uniform sampler2D tFrontFaceDepth;
    uniform sampler2D tFrontFaceNormal;
    uniform sampler2D tBackFaceDepth;
    uniform sampler2D tBackFaceNormal;
    uniform samplerCube tCube;
    uniform float zFar;
    uniform float zNear;
    uniform float width;
    uniform float height;
    uniform float windowDeviceRatio;
    uniform int renderFeature;

    varying vec3 vIncident;

    const float refractionIndex = 1.3;
    const float refractionDelta = 0.02;

    void main() {
        vec2 textureCoordinates = vec2(gl_FragCoord.x / (width), gl_FragCoord.y / (height));

        float frontFaceDepth = texture2D(tFrontFaceDepth, textureCoordinates).r;
        float backFaceDepth = texture2D(tBackFaceDepth, textureCoordinates).r;
        vec3 frontFaceNormal = texture2D(tFrontFaceNormal, textureCoordinates).rgb;
        vec3 backFaceNormal = texture2D(tBackFaceNormal, textureCoordinates).rgb;

        vec3 frontFaceRefractionR = refract(vIncident, frontFaceNormal, (1.0 / refractionIndex) + refractionDelta);
        vec3 frontFaceRefractionG = refract(vIncident, frontFaceNormal, 1.0 / refractionIndex);
        vec3 frontFaceRefractionB = refract(vIncident, frontFaceNormal, (1.0 / refractionIndex) - refractionDelta);

        vec3 backFaceRefractionR = refract(vIncident, backFaceNormal, (1.0 / refractionIndex) + refractionDelta);
        vec3 backFaceRefractionG = refract(vIncident, backFaceNormal, 1.0 / refractionIndex);
        vec3 backFaceRefractionB = refract(vIncident, backFaceNormal, (1.0 / refractionIndex) - refractionDelta);

        float colorFrontFaceRefractionR = textureCube(tCube, frontFaceRefractionR).r;
        float colorFrontFaceRefractionG = textureCube(tCube, frontFaceRefractionG).g;
        float colorFrontFaceRefractionB = textureCube(tCube, frontFaceRefractionB).b;

        float colorBackFaceRefractionR = textureCube(tCube, backFaceRefractionR).r;
        float colorBackFaceRefractionG = textureCube(tCube, backFaceRefractionG).g;
        float colorBackFaceRefractionB = textureCube(tCube, backFaceRefractionB).b;

        vec4 colorFrontFaceRefraction = vec4(colorFrontFaceRefractionR, colorFrontFaceRefractionG, colorFrontFaceRefractionB, 1.0);
        vec4 colorBackFaceRefraction = vec4(colorBackFaceRefractionR, colorBackFaceRefractionG, colorBackFaceRefractionB, 1.0);
        vec4 colorRefraction = mix(colorFrontFaceRefraction, colorBackFaceRefraction, 0.5);

        // Calculate reflection
        vec3 reflection = reflect(vIncident, frontFaceNormal);
        vec3 backFaceReflection = reflect(vIncident, backFaceNormal);
        vec4 colorReflection = textureCube(tCube, reflection);
        vec4 colorBackFaceReflection = textureCube(tCube, backFaceReflection);

        // Calculate depth effect
        float colorDepth = (backFaceDepth - frontFaceDepth);

        if (renderFeature == 0) {
            gl_FragColor = mix(mix(colorReflection, colorRefraction, 0.6), vec4(vec3(0.0), 1.0), colorDepth);
        } else if (renderFeature == 1) {
            gl_FragColor = vec4(backFaceNormal, 1.0);
        } else if (renderFeature == 2) {
            gl_FragColor = vec4(vec3(backFaceDepth), 1.0);
        } else if (renderFeature == 3) {
            gl_FragColor = vec4(frontFaceNormal, 1.0);
        } else if (renderFeature == 4) {
            gl_FragColor = vec4(vec3(frontFaceDepth), 1.0);
        } else if (renderFeature == 5) {
            gl_FragColor = vec4(vec3(backFaceDepth - frontFaceDepth), 1.0);
        } else if (renderFeature == 6) {
            gl_FragColor = colorBackFaceRefraction;
        } else if (renderFeature == 7) {
            gl_FragColor = colorFrontFaceRefraction;
        } else if (renderFeature == 8) {
            gl_FragColor = colorBackFaceReflection;
        } else if (renderFeature == 9) {
            gl_FragColor = colorReflection;
        }
    }

</script>

<script>
var renderer;
var controls;
var camera;
var backFaceScene, frontFaceScene;
var backFaceTarget, frontFaceTarget;
var postScene;
var supportsMRT = true;
var postMaterial;
var renderFeatures = {
    0: "Back-/Frontface Refraction, Reflection and Depth",
    1: "Backface Normals",
    2: "Backface Depth",
    3: "Frontface Normals",
    4: "Frontface Depth",
    5: "Depth Difference",
    6: "Backface Refraction",
    7: "Frontface Refraction",
    8: "Backface Reflection",
    9: "Frontface Reflection"
};
const maxRenderFeatures = 10;
$("#pass-button").text(renderFeatures[0]);

$(document).ready(function() {
    init();
    animate();
});

function init() {

    var cubeLoader = new THREE.CubeTextureLoader()
        .setPath('../assets/img/skybox/')
        .load([
            "posx.jpg",
            "negx.jpg",
            "posy.jpg",
            "negy.jpg",
            "posz.jpg",
            "negz.jpg"]
        );

    const zNear = 1.0;
    const zFar = 40.0;

    renderer = new THREE.WebGLRenderer({alpha: true});

    if ( !renderer.extensions.get('WEBGL_draw_buffers') ) {
        supportsMRT = false;
        alert("Your browser does not support WEBGL_draw_buffers. This demo will not work.");
        return;
    }

    // renderer.setPixelRatio( window.deviceRatio );
    renderer.setSize( window.innerWidth, window.innerHeight );
    document.body.appendChild(renderer.domElement);

    camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, zNear, zFar );
    camera.position.z = -15;

    controls = new THREE.OrbitControls( camera, renderer.domElement );
    controls.enableDamping = true;
    controls.dampingFactor = 0.25;
    controls.autoRotate = true;
    controls.autoRotateSpeed = 0.4;
    controls.rotateSpeed = 0.35;

    // Create a multi render target with Float buffers
    backFaceTarget = createTarget();
    frontFaceTarget = createTarget();

    backFaceScene = new THREE.Scene();
    frontFaceScene = new THREE.Scene();
    postScene = new THREE.Scene();

    const radius = 3.5;
    const tube = 1.5;
    const radialSegments = 16;
    const tubularSegments = 64;
    const p = 2;
    const q = 3;
    var geometry = new THREE.TorusKnotBufferGeometry(radius, tube, tubularSegments, radialSegments, p, q);

    // geometry = new THREE.BoxGeometry(10, 10, 10);
    //geometry = new THREE.SphereGeometry(10, 10, 10);

    var frontFaceMaterial = new THREE.RawShaderMaterial({
        side: THREE.FrontSide,
        uniforms: {
            zNear: { value: zNear },
            zFar: { value: zFar }
        },
        vertexShader: document.querySelector('#gbuffer-vert').textContent.trim(),
        fragmentShader: document.querySelector('#gbuffer-frag').textContent.trim()
    });
    var backFaceMaterial = new THREE.RawShaderMaterial({
        side: THREE.BackSide,
        uniforms: {
            zNear: { value: zNear },
            zFar: { value: zFar }
        },
        vertexShader: document.querySelector('#gbuffer-vert').textContent.trim(),
        fragmentShader: document.querySelector('#gbuffer-frag').textContent.trim()
    });
    postMaterial = new THREE.RawShaderMaterial({
        vertexShader: document.querySelector('#render-vert').textContent.trim(),
        fragmentShader: document.querySelector('#render-frag').textContent.trim(),
        uniforms: {
            zNear: { value: zNear },
            zFar: { value: zFar },
            width: { value: window.innerWidth },
            height: { value: window.innerHeight },
            tFrontFaceDepth: { type: 't', value: frontFaceTarget.attachments[0] },
            tFrontFaceNormal: { type: 't', value: frontFaceTarget.attachments[1] },
            tBackFaceDepth: { type: 't', value: backFaceTarget.attachments[0] },
            tBackFaceNormal: { type: 't', value: backFaceTarget.attachments[1] },
            tCube: { value: cubeLoader },
            renderFeature: {value: 0}
        }
    });

    var frontFaceTorus = new THREE.Mesh(geometry, frontFaceMaterial);
    var backFaceTorus = new THREE.Mesh(geometry, backFaceMaterial);
    var postSceneTorus = new THREE.Mesh(geometry, postMaterial);

    frontFaceScene.add(frontFaceTorus);
    backFaceScene.add(backFaceTorus);
    postScene.add(postSceneTorus);

    postScene.background = cubeLoader;

    onWindowResize();
    window.addEventListener( 'resize', onWindowResize, false );
}

function createTarget() {
    var t = new THREE.WebGLMultiRenderTarget( window.innerWidth, window.innerHeight );
    t.texture.format = THREE.RGBFormat;
    t.texture.minFilter = THREE.NearestFilter;
    t.texture.magFilter = THREE.NearestFilter;
    t.texture.type = THREE.FloatType;
    t.texture.generateMipmaps = false;
    t.stencilBuffer = false;
    t.depthBuffer = true;
    t.attachments.push( t.texture.clone() );
    return t;
}

function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();

    var dpr = renderer.getPixelRatio();
    frontFaceTarget.setSize( window.innerWidth * dpr, window.innerHeight * dpr );
    backFaceTarget.setSize( window.innerWidth * dpr, window.innerHeight * dpr );
    renderer.setSize( window.innerWidth, window.innerHeight );
}

function showNextPass() {
    const nextFeature = (postMaterial.uniforms.renderFeature.value + 1) % maxRenderFeatures;
    postMaterial.uniforms.renderFeature.value = nextFeature;
    $("#pass-button").text(renderFeatures[nextFeature]);
}

function animate() {

    if ( !supportsMRT ) return;
    controls.update();

    renderer.render( frontFaceScene, camera, frontFaceTarget );
    renderer.render( backFaceScene, camera, backFaceTarget );
    renderer.render( postScene, camera );

    requestAnimationFrame( animate );

}

</script>